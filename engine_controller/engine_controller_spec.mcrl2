act
	r_power, s_power, c_power: Nat # Bool;
	r_checkfuel, s_checkfuel, c_checkfuel: Nat # Bool;
	r_requestfix, s_requestfix, c_requestfix: Nat;
	r_requestcheck, s_requestcheck, c_requestcheck: Nat # Bool;

	check: Nat # Nat;
	fix: Nat;
	power: Nat # Bool;
	checkfuel: Nat;

proc
	EC 								= EC_requestcheck + sum module: Nat.(module <= 1) -> (EC_checkfuel(module) + EC_power(module));

	EC_checkfuel(module: Nat) 		= sum b: Bool . r_checkfuel(module,b) . checkfuel(module) . (b -> s_checkfuel(module,true).EC <> s_checkfuel(module,false)) . EC;
	EC_power(module: Nat) 			= sum b: Bool . r_power(module,b) . power(module,b) . (b -> r_power(module,true).EC <> r_power(module,false)) . EC;
	EC_requestcheck 				= sum b: Bool . r_requestcheck(3,b) . sum module: Nat . (module <= 1) -> check(3,module) . b -> s_requestcheck(3, true) . EC <> s_requestcheck(3,false) . s_requestfix(3) . EC_readyfix(module);
	EC_readyfix(module: Nat) 		= fix(module) . sum b: Bool . (b -> r_requestcheck(3,true) <> r_requestcheck(3, false)) . EC;

init
EC;
	%allow({c_power, c_checkfuel, c_requestfix, c_requestcheck, check, fix, power, checkfuel},
	%comm({	r_power|s_power -> c_power,
	%		r_checkfuel|s_checkfuel -> c_checkfuel,
	%		r_requestfix|s_requestfix -> c_requestfix,
	%		r_requestcheck|s_requestcheck -> c_requestcheck},
	%EC));